<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Invisible Air Guitar</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #ff6b6b 0%, #4ecdc4 100%);
            color: white;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            text-align: center;
        }
        
        h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .subtitle {
            font-size: 1.2rem;
            margin-bottom: 30px;
            opacity: 0.9;
        }
        
        #videoContainer {
            position: relative;
            display: inline-block;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
        }
        
        #video {
            width: 640px;
            height: 480px;
            background: #000;
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        
        .controls {
            margin: 30px 0;
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }
        
        button, select {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            background: rgba(255,255,255,0.2);
            color: white;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        button:hover, select:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        select option {
            background: #333;
            color: white;
        }
        
        .guitar-strings {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .string {
            display: flex;
            align-items: center;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            backdrop-filter: blur(10px);
            transition: all 0.2s ease;
        }
        
        .string.active {
            background: rgba(255,255,255,0.4);
            transform: scale(1.02);
        }
        
        .string-name {
            width: 60px;
            font-weight: bold;
            font-size: 1.2rem;
        }
        
        .string-line {
            flex: 1;
            height: 4px;
            background: linear-gradient(90deg, #555, #888);
            border-radius: 2px;
            margin: 0 15px;
            position: relative;
            overflow: hidden;
        }
        
        .string-vibration {
            position: absolute;
            top: 0;
            left: 0;
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ffeb3b, #ff9800);
            border-radius: 2px;
            transition: width 0.1s ease;
        }
        
        .fret-indicator {
            width: 60px;
            text-align: center;
            font-size: 0.9rem;
            opacity: 0.7;
        }
        
        .status {
            margin: 20px 0;
            font-size: 1.1rem;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            display: inline-block;
        }
        
        .gesture-info {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .gesture-box {
            padding: 10px 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            min-width: 120px;
        }
        
        .gesture-box.active {
            background: rgba(255,255,255,0.3);
        }
        
        .instructions {
            margin: 30px 0;
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .chord-display {
            margin: 20px 0;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            font-size: 1.5rem;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ¸ Invisible Air Guitar ðŸŽ¸</h1>
        <p class="subtitle">Strum and fret in the air to play guitar!</p>
        
        <div class="status" id="status">Click "Start Camera" to begin</div>
        
        <div class="controls">
            <button id="startBtn" onclick="startCamera()">Start Camera</button>
            <button id="stopBtn" onclick="stopCamera()" disabled>Stop</button>
            <button id="testSoundBtn" onclick="testSound()">Test Sound</button>
            <select id="scaleSelect" onchange="changeScale()">
                <option value="major">C Major</option>
                <option value="minor">C Minor</option>
                <option value="pentatonic">C Pentatonic</option>
                <option value="blues">C Blues</option>
            </select>
            <select id="chordModeSelect" onchange="toggleChordMode()">
                <option value="false">Single Notes</option>
                <option value="true">Chord Mode</option>
            </select>
        </div>
        
        <div class="chord-display" id="chordDisplay">Ready to play!</div>
        
        <div id="videoContainer">
            <video id="video" autoplay muted></video>
            <canvas id="canvas" width="640" height="480"></canvas>
        </div>
        
        <div class="gesture-info">
            <div class="gesture-box" id="gesture-strum">
                <h4>Strumming</h4>
                <p id="strumStatus">Idle</p>
            </div>
            <div class="gesture-box" id="gesture-fret">
                <h4>Fretting</h4>
                <p id="fretStatus">Open</p>
            </div>
            <div class="gesture-box" id="gesture-pick">
                <h4>Picking</h4>
                <p id="pickStatus">None</p>
            </div>
        </div>
        
        <div class="guitar-strings">
            <div class="string" id="string-0">
                <div class="string-name">E (1st)</div>
                <div class="string-line"><div class="string-vibration" id="vib-0"></div></div>
                <div class="fret-indicator" id="fret-0">0</div>
            </div>
            <div class="string" id="string-1">
                <div class="string-name">B (2nd)</div>
                <div class="string-line"><div class="string-vibration" id="vib-1"></div></div>
                <div class="fret-indicator" id="fret-1">0</div>
            </div>
            <div class="string" id="string-2">
                <div class="string-name">G (3rd)</div>
                <div class="string-line"><div class="string-vibration" id="vib-2"></div></div>
                <div class="fret-indicator" id="fret-2">0</div>
            </div>
            <div class="string" id="string-3">
                <div class="string-name">D (4th)</div>
                <div class="string-line"><div class="string-vibration" id="vib-3"></div></div>
                <div class="fret-indicator" id="fret-3">0</div>
            </div>
            <div class="string" id="string-4">
                <div class="string-name">A (5th)</div>
                <div class="string-line"><div class="string-vibration" id="vib-4"></div></div>
                <div class="fret-indicator" id="fret-4">0</div>
            </div>
            <div class="string" id="string-5">
                <div class="string-name">E (6th)</div>
                <div class="string-line"><div class="string-vibration" id="vib-5"></div></div>
                <div class="fret-indicator" id="fret-5">0</div>
            </div>
        </div>
        
        <div class="instructions">
            <h3>How to Play:</h3>
            <p>â€¢ <strong>Left Hand (Fretting):</strong> Move up/down to change fret position</p>
            <p>â€¢ <strong>Right Hand (Strumming):</strong> Move side-to-side across strings</p>
            <p>â€¢ <strong>Picking:</strong> Quick downward motions to pick individual strings</p>
            <p>â€¢ <strong>Chord Mode:</strong> Play full chords with strumming motions</p>
            <p>â€¢ Try different scales and experiment with chord progressions!</p>
        </div>
    </div>

    <script>
    let video, canvas, ctx;
    let hands, camera;
    let isRunning = false;
    let lastHandPos = { left: null, right: null };
    let currentScale = 'major';
    let chordMode = false;
    let currentFret = 0;
    let lastStrum = 0;
    let audioUnlocked = false;
    // Audio setup
    let audioContext;
    let guitarSounds = {};
    let sustainedNotes = new Map();
        
        // Guitar tuning (standard tuning in Hz)
        const stringFrequencies = [
            329.63, // E4 (1st string)
            246.94, // B3 (2nd string) 
            196.00, // G3 (3rd string)
            146.83, // D3 (4th string)
            110.00, // A2 (5th string)
            82.41   // E2 (6th string)
        ];
        
        // Scale patterns (semitones from root)
        const scales = {
            major: [0, 2, 4, 5, 7, 9, 11],
            minor: [0, 2, 3, 5, 7, 8, 10],
            pentatonic: [0, 2, 4, 7, 9],
            blues: [0, 3, 5, 6, 7, 10]
        };
        
        // Basic chord shapes (fret positions for each string)
        const chords = {
            'C': [0, 1, 0, 2, 3, 0],
            'G': [3, 0, 0, 0, 2, 3],
            'Am': [0, 1, 2, 2, 0, 0],
            'F': [1, 1, 2, 3, 3, 1],
            'Dm': [1, 3, 2, 0, 0, 0],
            'Em': [0, 0, 0, 2, 2, 0]
        };
        
        async function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            // Create guitar string sound generator
            const createGuitarString = (frequency, duration = 2.0) => {
                return (volume = 0.5, sustain = false) => {
                    const oscillator1 = audioContext.createOscillator();
                    const oscillator2 = audioContext.createOscillator();
                    const oscillator3 = audioContext.createOscillator();
                    
                    const gainNode = audioContext.createGain();
                    const filterNode = audioContext.createBiquadFilter();
                    const delayNode = audioContext.createDelay(0.1);
                    const delayGain = audioContext.createGain();
                    
                    // Main frequency
                    oscillator1.frequency.setValueAtTime(frequency, audioContext.currentTime);
                    oscillator1.type = 'sawtooth';
                    
                    // Harmonic (octave)
                    oscillator2.frequency.setValueAtTime(frequency * 2, audioContext.currentTime);
                    oscillator2.type = 'sine';
                    
                    // Sub harmonic
                    oscillator3.frequency.setValueAtTime(frequency * 0.5, audioContext.currentTime);
                    oscillator3.type = 'triangle';
                    
                    // Connect oscillators
                    oscillator1.connect(gainNode);
                    oscillator2.connect(gainNode);
                    oscillator3.connect(gainNode);
                    
                    // Add some delay for reverb effect
                    gainNode.connect(filterNode);
                    filterNode.connect(delayNode);
                    delayNode.connect(delayGain);
                    delayGain.connect(filterNode);
                    filterNode.connect(audioContext.destination);
                    
                    // Filter settings
                    filterNode.type = 'lowpass';
                    filterNode.frequency.setValueAtTime(frequency * 4, audioContext.currentTime);
                    filterNode.Q.setValueAtTime(1, audioContext.currentTime);
                    
                    // Delay settings
                    delayNode.delayTime.setValueAtTime(0.05, audioContext.currentTime);
                    delayGain.gain.setValueAtTime(0.1, audioContext.currentTime);
                    
                    // Envelope
                    const baseVolume = volume * 0.3;
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(baseVolume, audioContext.currentTime + 0.01);
                    
                    if (sustain) {
                        gainNode.gain.setValueAtTime(baseVolume * 0.7, audioContext.currentTime + 0.1);
                    } else {
                        gainNode.gain.exponentialRampToValueAtTime(baseVolume * 0.1, audioContext.currentTime + 0.5);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
                    }
                    
                    oscillator1.start(audioContext.currentTime);
                    oscillator2.start(audioContext.currentTime);
                    oscillator3.start(audioContext.currentTime);
                    
                    if (!sustain) {
                        oscillator1.stop(audioContext.currentTime + duration);
                        oscillator2.stop(audioContext.currentTime + duration);
                        oscillator3.stop(audioContext.currentTime + duration);
                    }
                    
                    return { oscillator1, oscillator2, oscillator3, gainNode };
                };
            };
            
            // Create sounds for each string
            guitarSounds = stringFrequencies.map(freq => createGuitarString(freq));
        }
        
        async function startCamera() {
            if (!audioUnlocked) {
                document.getElementById('status').textContent = 'Please click "Test Sound" to unlock audio before starting.';
                return;
            }
            try {
                await initAudio();
                video = document.getElementById('video');
                canvas = document.getElementById('canvas');
                ctx = canvas.getContext('2d');
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: 640, height: 480 } 
                });
                video.srcObject = stream;
                // Initialize MediaPipe Hands
                if (typeof Hands === 'undefined' || typeof Camera === 'undefined') {
                    document.getElementById('status').textContent = 'Error: MediaPipe Hands or Camera not loaded.';
                    return;
                }
                hands = new Hands({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
                });
                hands.setOptions({
                    maxNumHands: 2,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.7,
                    minTrackingConfidence: 0.5
                });
                hands.onResults(onResults);
                camera = new Camera(video, {
                    onFrame: async () => {
                        if (isRunning) {
                            await hands.send({ image: video });
                        }
                    },
                    width: 640,
                    height: 480
                });
                await camera.start();
                isRunning = true;
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('status').textContent = 'Camera running - Start playing!';
            } catch (error) {
                console.error('Error starting camera:', error);
                document.getElementById('status').textContent = 'Error: Could not access camera or microphone. Make sure you are running this from a local server (not file://) and have given permission.';
            }
        }
        
        function stopCamera() {
            if (camera) {
                camera.stop();
            }
            if (video && video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
            }
            isRunning = false;
            // Stop all sustained notes
            sustainedNotes.forEach(note => {
                if (note.gainNode) {
                    note.gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
                }
            });
            sustainedNotes.clear();
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('status').textContent = 'Camera stopped';
            if (ctx && canvas) ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        function onResults(results) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
            
            let leftHand = null;
            let rightHand = null;
            
            if (results.multiHandLandmarks) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const landmarks = results.multiHandLandmarks[i];
                    const handedness = results.multiHandedness[i].label;
                    
                    // Draw hand landmarks
                    drawConnectors(ctx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                    drawLandmarks(ctx, landmarks, {color: '#FF0000', radius: 3});
                    
                    if (handedness === 'Left') {
                        rightHand = landmarks; // Camera is mirrored
                    } else {
                        leftHand = landmarks;
                    }
                }
            }
            
            // Process guitar playing
            processGuitarPlaying(leftHand, rightHand);
        }
        
        function processGuitarPlaying(leftHand, rightHand) {
            // Left hand controls fretting
            if (leftHand) {
                processFretting(leftHand);
            }
            
            // Right hand controls strumming/picking
            if (rightHand) {
                processStrumming(rightHand);
            }
            
            // Update UI
            updateUI();
        }
        
        function processFretting(hand) {
            const wrist = hand[0];
            const middleFinger = hand[12];
            
            // Calculate fret based on Y position (higher = higher fret)
            const fretPosition = Math.max(0, Math.min(12, Math.floor((1 - wrist.y) * 12)));
            currentFret = fretPosition;
            
            // Update fret display
            for (let i = 0; i < 6; i++) {
                document.getElementById(`fret-${i}`).textContent = currentFret;
            }
            
            document.getElementById('fretStatus').textContent = `Fret ${currentFret}`;
            document.getElementById('gesture-fret').classList.add('active');
            setTimeout(() => {
                document.getElementById('gesture-fret').classList.remove('active');
            }, 100);
        }
        
        function processStrumming(hand) {
            const wrist = hand[0];
            const indexTip = hand[8];
            
            const currentPos = {
                x: wrist.x * canvas.width,
                y: wrist.y * canvas.height
            };
            
            let velocity = 0;
            let horizontalVelocity = 0;
            
            if (lastHandPos.right) {
                const dx = currentPos.x - lastHandPos.right.x;
                const dy = currentPos.y - lastHandPos.right.y;
                velocity = Math.sqrt(dx*dx + dy*dy);
                horizontalVelocity = Math.abs(dx);
            }
            
            const now = Date.now();
            
            // Detect strumming motion (horizontal movement)
            if (horizontalVelocity > 10 && velocity > 15 && now - lastStrum > 200) {
                if (chordMode) {
                    strumChord(velocity / 20);
                } else {
                    const stringIndex = getStringFromPosition(wrist.y);
                    if (stringIndex !== -1) {
                        playString(stringIndex, velocity / 20);
                    }
                }
                lastStrum = now;
                
                document.getElementById('strumStatus').textContent = 'Strumming!';
                document.getElementById('gesture-strum').classList.add('active');
                setTimeout(() => {
                    document.getElementById('strumStatus').textContent = 'Idle';
                    document.getElementById('gesture-strum').classList.remove('active');
                }, 200);
            }
            
            // Detect picking motion (quick downward movement)
            if (velocity > 20 && Math.abs(currentPos.y - (lastHandPos.right?.y || 0)) > 5) {
                const stringIndex = getStringFromPosition(wrist.y);
                if (stringIndex !== -1 && now - lastStrum > 100) {
                    playString(stringIndex, Math.min(velocity / 15, 1));
                    lastStrum = now;
                    
                    document.getElementById('pickStatus').textContent = `String ${stringIndex + 1}`;
                    document.getElementById('gesture-pick').classList.add('active');
                    setTimeout(() => {
                        document.getElementById('pickStatus').textContent = 'None';
                        document.getElementById('gesture-pick').classList.remove('active');
                    }, 150);
                }
            }
            
            lastHandPos.right = currentPos;
        }
        
        function getStringFromPosition(y) {
            // Map Y position to string (0-5)
            const stringIndex = Math.floor(y * 6);
            return Math.max(0, Math.min(5, stringIndex));
        }
        
        function playString(stringIndex, volume = 0.5) {
            // Calculate frequency based on fret
            const baseFreq = stringFrequencies[stringIndex];
            const frettedFreq = baseFreq * Math.pow(2, currentFret / 12);
            
            // Stop any existing note on this string
            if (sustainedNotes.has(stringIndex)) {
                const note = sustainedNotes.get(stringIndex);
                if (note.gainNode) {
                    note.gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.05);
                }
                sustainedNotes.delete(stringIndex);
            }
            
            // Play new note
            const stringSound = createGuitarString(frettedFreq, 2.0);
            const note = stringSound(volume, false);
            
            // Visual feedback
            animateString(stringIndex, volume);
        }
        
        function strumChord(volume = 0.5) {
            // Play a chord based on current fret position
            const chordNames = Object.keys(chords);
            const chordName = chordNames[currentFret % chordNames.length];
            const chordShape = chords[chordName];
            
            document.getElementById('chordDisplay').textContent = `Playing: ${chordName}`;
            
            // Play each string in the chord with slight delay for natural strum effect
            chordShape.forEach((fret, stringIndex) => {
                setTimeout(() => {
                    const baseFreq = stringFrequencies[stringIndex];
                    const frettedFreq = baseFreq * Math.pow(2, fret / 12);
                    const stringSound = createGuitarString(frettedFreq, 1.5);
                    stringSound(volume * 0.8, false);
                    animateString(stringIndex, volume);
                }, stringIndex * 20); // 20ms delay between strings
            });
        }
        
        function createGuitarString(frequency, duration) {
            return (volume = 0.5, sustain = false) => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                const filterNode = audioContext.createBiquadFilter();
                
                oscillator.connect(filterNode);
                filterNode.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                oscillator.type = 'sawtooth';
                
                filterNode.type = 'lowpass';
                filterNode.frequency.setValueAtTime(frequency * 3, audioContext.currentTime);
                filterNode.Q.setValueAtTime(1, audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(volume * 0.3, audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(volume * 0.1, audioContext.currentTime + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
                
                return { oscillator, gainNode };
            };
        }
        
        function animateString(stringIndex, intensity) {
            const stringElement = document.getElementById(`string-${stringIndex}`);
            const vibrationElement = document.getElementById(`vib-${stringIndex}`);
            
            stringElement.classList.add('active');
            vibrationElement.style.width = (intensity * 100) + '%';
            
            setTimeout(() => {
                stringElement.classList.remove('active');
                vibrationElement.style.width = '0%';
            }, 300);
        }
        
        function updateUI() {
            // Update chord display based on current mode
            if (!chordMode) {
                document.getElementById('chordDisplay').textContent = `Fret ${currentFret} - Single Note Mode`;
            }
        }
        
        function changeScale() {
            currentScale = document.getElementById('scaleSelect').value;
        }
        
        function toggleChordMode() {
            chordMode = document.getElementById('chordModeSelect').value === 'true';
        }

        // Audio unlock and test sound
        function testSound() {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                // Unlock audio context
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                audioUnlocked = true;
                // Play a test note
                const testOsc = audioContext.createOscillator();
                const testGain = audioContext.createGain();
                testOsc.type = 'sine';
                testOsc.frequency.setValueAtTime(440, audioContext.currentTime);
                testGain.gain.setValueAtTime(0, audioContext.currentTime);
                testGain.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.01);
                testGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
                testOsc.connect(testGain);
                testGain.connect(audioContext.destination);
                testOsc.start();
                testOsc.stop(audioContext.currentTime + 0.5);
                document.getElementById('status').textContent = 'Audio unlocked! You can now start the camera.';
            } catch (err) {
                document.getElementById('status').textContent = 'Error unlocking audio: ' + err.message;
            }
        }
        
        // MediaPipe drawing utilities
        function drawConnectors(ctx, landmarks, connections, options) {
            ctx.strokeStyle = options.color || '#00FF00';
            ctx.lineWidth = options.lineWidth || 2;
            
            for (let connection of connections) {
                const start = landmarks[connection[0]];
                const end = landmarks[connection[1]];
                
                ctx.beginPath();
                ctx.moveTo(start.x * canvas.width, start.y * canvas.height);
                ctx.lineTo(end.x * canvas.width, end.y * canvas.height);
                ctx.stroke();
            }
        }
        
        function drawLandmarks(ctx, landmarks, options) {
            ctx.fillStyle = options.color || '#FF0000';
            
            for (let landmark of landmarks) {
                ctx.beginPath();
                ctx.arc(
                    landmark.x * canvas.width,
                    landmark.y * canvas.height,
                    options.radius || 3,
                    0,
                    2 * Math.PI
                );
                ctx.fill();
            }
        }
        
        // MediaPipe constants
        const HAND_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4],
            [0, 5], [5, 6], [6, 7], [7, 8],
            [5, 9], [9, 10], [10, 11], [11, 12],
            [9, 13], [13, 14], [14, 15], [15, 16],
            [13, 17], [17, 18], [18, 19], [19, 20],
            [0, 17]
        ];
    </script>
</body>
</html>